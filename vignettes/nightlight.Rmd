---
title: "nightlight"
author: "Pilar Delpino Marimon"
date: "7/21/2022"
vignette: >
  %\VignetteIndexEntry{nightlight}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

# install libraries

```{r}
install.packages(c("here", "geojsonsf", "sp", "sf", "terra", "raster",
                   "exactextractr", "dplyr", "tidyr", "zoo", "rgdal", "classInt",
                   "ggplot2", "RColorBrewer", "viridis", "kableExtra"))

```

# Load Libraries

```{r include=FALSE}
#library(USFlite)
library(here)
library(geojsonsf) 
library(sp)
library(sf)
library(terra) 
library(raster)
library(exactextractr) 
library(dplyr)
library(tidyr)
library(zoo)
library(rgdal)
library(classInt)
library(ggplot2)
library(RColorBrewer) # Use for color palettes
library(viridis) # Use for color palettes
library(kableExtra) # Use for data table formatting
```

# Load shapefiles - Proj: New York State Plane Long Island Zone (EPSG 2263)

```{r include=FALSE}
# NYC census tracts
nytract <- readRDS(here("nightlight/nytract.RDS")) 

# NYC public housing developments
nycha <- readRDS(here("nightlight/nycha.RDS")) 

# Polo Grounds Towers to test hypothesis - capture floodlight presence
polo <- readRDS(here("nightlight/polo.RDS"))

# Import population data
ny_pop <- readRDS(here("nightlight/ny_pop.RDS")) 

# Download geojson of NYC building footprints
# download.file("https://www.dropbox.com/s/o1griqqa1biezpc/buildings.geojson?dl=1",
#                           destfile = "~/USFlite/nightlight/buildings.geojson")

# Read buildings geojson
#buildings <- geojson_sf("~/USFlite/nightlight/buildings.geojson") 
buildings <- geojson_sf("~/Clark/RA-ing/SummerInstitute/nightlight/data/buildings.geojson")

# BLM protests at night
blm_pts_night <- readRDS(here("nightlight/blm_pts_night.RDS"))
```

### Display tracts with public housing in blue, and Polo Grounds in red with circle hightlighting the area

```{r echo=FALSE}
ggplot() +
  geom_sf(data = nytract, col = alpha("grey9", 0.1), fill = "grey") +
  geom_sf(data = nycha, aes(fill = 'A'), col = "blue4", 
          show.legend = "polygon", inherit.aes = F) +
  geom_sf(data = polo, aes(fill = 'B'), col = NA,
          show.legend = "polygon", inherit.aes = F) +
  geom_sf(data = polo %>% st_geometry() %>% st_centroid() %>% st_buffer(2000), 
          fill = NA, col = 'red4', 
          show.legend = F, inherit.aes = F) +
  ggtitle("NYC Public Housing Developments") +
  scale_fill_manual(values = c("A" = "blue", "B" = "red"), 
                    labels = c("Public Housing Developments", 
                               "Polo Grounds Towers")) +
  xlab('') + ylab('') +
  theme_bw() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.title = element_blank(),
        axis.text.y = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks = element_blank(),
        legend.position = c(0.22, 0.92)) 
```

## Masked visualization of the mean NYC nighttime lights from 2012 to 2022.

```{r}
# load raster stack
s <- stack(here("nightlight/s.tif"))
# load names
n <- readRDS(here("nightlight/n.RDS")) 
# assign names to stack
names(s) <- n
plot(s)

# calculate mean radiance
mean_s <- calc(s, mean, na.rm = TRUE)
plot(mean_s)

# Convert raster to dataframe for plotting
mean_s_df <- as.data.frame(rasterToPoints(mean_s))
colnames(mean_s_df) <- c('x', 'y', 'value')
```

### Plot long term mean of nighttime lights for NYC

```{r}
ggplot() + 
  geom_raster(aes(x = x, y = y, fill = value), data = mean_s_df) +
  ggtitle("NYC Nighttime Lights mean radiance 2012 - 2022") +
  scale_fill_viridis(guide = guide_colorbar(title = "nWatts·cm−2·sr−1", 
                                             ticks = FALSE)) +
  xlab('') + ylab('') +
  theme_bw() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.text.y = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks = element_blank(),
        legend.position = c(0.2, 0.8)) 
```

#  Testing hypthesis: detect light installation on Polo Grounds Towers

```{r}
#Names of each layer aka dates in format Xyyyyjjj
 names_s <- names(s)

# taking out the X in the dates
dates_yj <- as.data.frame(names_s) %>%  lapply(., function(x) {
  gsub("X", "", x)})

#converting from yyyyjjj to date data format
dates <- lapply(dates_yj, function(x) {
  as.Date(x, format = "%Y%j")
})

#adding dates as z value to each layer
p <- as.data.frame(dates)
s2 <- setZ(s, p[,1], "date")
dates <- getZ(s2)
class(getZ(s2)) 
print(s2)
```

```{r}
#Query Formatting
instal_sub <- subset(s2, which(getZ(s2) >= '2015-7-01' & 
                                 (getZ(s2) <= '2016-03-10')))
plot(instal_sub)

#Getting subsets of before and after year of known installation 
before_inst_sub <- subset(s2, which(getZ(s2) <= '2015-07-01' & 
                                  (getZ(s2) >= '2014-07-01')))
plot(before_inst_sub)

after_inst_sub <- subset(s2, which(getZ(s2) >= '2016-03-10' & 
                                 (getZ(s2) <= '2017-03-10')))
plot(after_inst_sub)

#Creating one year means before and after the installation of lights at Polo Grounds

before_mean <- calc(before_inst_sub, mean, na.rm = TRUE)
plot(before_mean)

after_mean <- calc(after_inst_sub, mean, na.rm = TRUE)
plot(after_mean)


#Plots of before and after means 
ba_mean_s <- stack(before_mean, after_mean)
names(ba_mean_s) <- c("Aug_2014-2015", "Aug_2016-2017")
plot(ba_mean_s)

#Anomalies of radinace, from before and after light installation
diff <- (after_mean - before_mean)
plot(diff)

#Histogram of the difference, where positive values indicate increase in values and negative indicates decrease in values
par(mar = c(3, 3, 3, 3))
hist(diff, col = "blue", xlab = "iradiance", breaks = 12)

#cropping the anamoly for Polo Grounds, turns out only 1 pixel
rpolo_ann <- crop(x = diff, y = st_transform(polo, st_crs(diff)))
plot(rpolo_ann)
plot(st_transform(polo, st_crs(diff))$geometry, add = T)
```


### Subsetting on a ~3 year time frame of before during and after light installation to see if one can find anomalies 

```{r}
# reproject polo to WGS 84, EPSG:4326 
polo <- polo %>% st_transform(., crs = 4326)

sub1 <- subset(s2, which(getZ(s2) >= '2014-07-01' & (getZ(s2) <= '2017-06-30')))
plot(sub1)

polo_s <- crop(x = sub1, y = st_transform(polo, st_crs(sub1)))

st_bbox(polo_s)
st_bbox(polo)
plot(polo_s[[5]])
plot(polo$geometry, add = TRUE)

polo_frame <- raster::extract(
  x = polo_s, 
  y = st_transform(polo, st_crs(polo_s)), small = TRUE, 
  na.rm = TRUE) %>% unlist(.) %>% as.data.frame(.) #%>% 
 # mutate(., date = getZ(sub1)) # this line doesn't work

bb <- st_bbox(st_transform(polo, st_crs(polo_s)))
plot(polo_s[[5]], xlim = bb[c(1, 3)], ylim = bb[c(2, 4)])
bb
st_transform(polo, st_crs(polo_s))


polo_roll <- polo_frame %>% mutate(month_av = rollapply(polo[[1]], 
              width = 30, FUN = function(x) mean(x, na.rm = TRUE), fill = NA))
```

### Creation of 30 day rolling mean of 3 year chunk analyzed above to display why a decrease in radiance is seen

```{r}
polo_roll %>% 
ggplot() + 
  geom_line(mapping = aes(x = date, y = month_av), size = 1.2, col = "blue") +
  geom_line(polo_roll[(361:614),], mapping = aes(x = date, y = month_av), 
            size = 1.2, col = "red") +
  xlab("Date") + ylab("Radiancen (Watts·cm^−2·sr^−1)") +
  ggtitle("Polo Grounds 30 day rolling mean with light installation period highlighted in red") 
```

### Seeing Polo Grounds in the context of the whole time series by doing a 30 day rolling mean.


```{r}

# Cropping the time series to Polo Grounds
polo_s2 <- crop(x = s2, y = polo) # error no non-missing arguments to min
# Making a data frame from those radiance values form all the layers
polo_frame_full_full <- raster::extract(x = polo_s2,
                   y = polo, exact = TRUE, na.rm = TRUE) %>% unlist(.) %>% 
                  as.data.frame(.) %>% mutate(., date = getZ(s2))
# Executing a rolling mean of 30 days across the whole time series and saving it as a new column in the data frame.
polo_roll_full <- polo_frame_full_full %>%
  mutate(month_av = rollapply(polo_frame_full_full[[1]],
                width = 30, FUN = function(x) mean(x, na.rm = TRUE), fill = NA))
# NA values are excluded from this rolling mean and the first 15 are NA.
```

```{r}
polo_roll_full %>% 
ggplot() + geom_line(mapping = aes(x = date, y = month_av), col = "blue", size = 1.2) +
  geom_line(polo_roll_full[(1244:1497), ], 
            mapping = aes(x = date, y = month_av), col = "red", size = 1.2) +
  ggtitle("Rolling 30 day mean over Polo Grounds with light installation period highlighted in red") +
  ylab("Radaice (Watts·cm^−2·sr^−1)") + xlab(NULL) 
```

### Looking at quarterly means to smooth over short term trends.

```{r}
# Summarizing the radiance values over Polo Grounds by 3-month means in an effort
# to lessen the influence of the February spike in radiance seen every year. 
zoo_frame <- polo_roll_full %>% 
  mutate(quarter = as.yearqtr(polo_roll_full$date, format = "%Y-%m-%d")) %>%
  mutate(radiance = as.numeric(polo_roll_full$.)) %>% 
  group_by(quarter) %>% 
  summarise(., mean = mean(radiance, na.rm = TRUE)) %>% 
  as.data.frame(.) %>% 
  mutate(year = as.yearqtr(.$quarter, format = "%y/0%q") %>%
  format(., format = "%y")) %>%
  mutate(row_num = seq.int(nrow(.))) %>% 
  mutate(group = ifelse(row_num < 15, "Before", 
                        ifelse(row_num > 17, "After", "During")))
# Looking at the difference of before and after installation with full time scale
zoo_table <- zoo_frame %>% 
  group_by(group) %>% 
  summarise(., mean = round(mean(mean))) %>% 
  as.data.frame(.) 
# Adding the difference row in the table
zoo_table[nrow(zoo_table) + 1, ] <- c("difference", 
                                      (zoo_table$mean[1] - zoo_table$mean[2]))
# Creation of a more visually appealing table
zoo_table %>% kable() %>% kable_styling()

```

### Line plot of quarterly 

```{r}
ggplot(zoo_frame) +
  geom_line(aes(x = quarter, y = mean), size = 0.5) + ylab("Radiance") +
  geom_point(mapping = aes(x = quarter, y = mean, color = group), size = 2) +
  xlab(NULL) +
  ggtitle("Comparison of radiance of before and after
light instalation at Polo Grounds by looking at quarterly means") 
```

# BLM Protest Analysis

### Visualize Night protest points
```{r}
par(mar = c(0, 0, 1, 0))
plot(nytract %>% st_geometry(), col = "grey", pch = NA, border = "grey9", 
     main = "BLM Protest Locations")
plot(blm_pts_night %>% st_geometry(), col = "blue", pch = 16, add = TRUE)
```


## Plotting long term mean of Nighttime lights with BLM Protest Points on top. 

```{r, error = TRUE, warning = FALSE, message = FALSE, fig.height = 6, eval = FALSE}
ggplot() + 
  geom_raster(aes(x = x, y = y, fill = value), data = mean_s_df) +
  geom_sf(data = nytract, fill = NA, col = alpha("white", 0.2)) +
  geom_sf(data = blm_pts_night_night, fill = NA, col = "deeppink") + 
  ggtitle("Mean Radiance 2012 - 2022 with BLM Protest Points") +
  scale_fill_gradient(low = 'black', high = 'yellow',
                      guide = guide_colorbar(title = "", 
                                             ticks = FALSE)) +
  xlab('') + ylab('') +
  coord_sf(expand = 0) +
  theme_minimal() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.text.y = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks = element_blank()) 
```

### Polo Ground Code / BLM Protest Point Work Space

Using NASA black marble to evaluate mean nighttime lights and dates. 

Figuring out means for BLM Protest Areas using Polo Ground and NASA Black Marble data.

```{r}
#Getting subsets of before and after year of known installation 
blm_2020_sub <- subset(s2, which(getZ(s2) >= '2020-5-28' & 
                                   (getZ(s2) <= '2020-06-01')))
blm_2019_sub <- subset(s2, which(getZ(s2) >= '2019-5-28' & 
                                   (getZ(s2) <= '2019-06-01')))
blm_2018_sub <- subset(s2, which(getZ(s2) >= '2018-5-28' & 
                                   (getZ(s2) <= '2018-06-01')))
blm_2017_sub <- subset(s2, which(getZ(s2) >= '2017-5-28' & 
                                   (getZ(s2) <= '2017-06-01')))

#Creating one year means before and after the installation of lights at Polo Grounds
blm_2020_mean <- mean(blm_2020_sub, na.rm = TRUE)
blm_2019_mean <- mean(blm_2019_sub, na.rm = TRUE)
blm_2018_mean <- mean(blm_2018_sub, na.rm = TRUE)
blm_2017_mean <- mean(blm_2017_sub, na.rm = TRUE)

#Plots of before and after means 
blm_mean_s <- stack(blm_2020_mean, blm_2019_mean, blm_2019_mean, blm_2017_mean)
names(blm_mean_s) <- c("May_June_2020", "May_June_2019", 
                       "May_June_2018", "May_June_2017")
blm_mean_overtime <- plot(blm_mean_s)

```

# Public Housing Lights Analysis


```{r}
# Define raster with extent and resolution as mean nighttime lights
r <- mean_s
values(r) <- 1:ncell(r)

# Create raster with proportion of pixel covered by public housing
city_background <- pop_r
city_background[city_background >= 0] <- 0

ph_fraction <- coverage_fraction(r, st_combine(nycha))[[1]]
ph_fraction[is.na(ph_fraction)] <- 0

ph_fraction <- mask(ph_fraction, city_background)

ph_frac_df <- as.data.frame(rasterToPoints(ph_fraction))
colnames(ph_frac_df) <- c('x', 'y', 'value')
ph_frac_df <- ph_frac_df %>% filter(!is.na(value)) 
```

### Plot fractional coverage image of public housing tracts


```{r}
ggplot() + 
  geom_sf(data = nytract, col = "lightgrey", fill = NA) +
  geom_raster(aes(x = x, y = y, fill = value), data = ph_frac_df) +
  ggtitle("Proportion of pixel area with public housing") +
  scale_fill_viridis_b(breaks = seq(0, 0.8, 0.1), 
                     guide = guide_colorbar(title = "", 
                                            ticks = FALSE)) +
  xlab('') + ylab('') +
  coord_sf() +
  theme_bw() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.text.y = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks = element_blank(),
        legend.position = c(0.1, 0.85)) 
```

# Create gridded population from census tracts

The map below shows the area proportion of 500 m pixels covered with public housing developments

## Create areal interpolated population grid
```{r}
# Add area to census tracts then join population data
nytract_pop <- nytract %>% 
  mutate(area = as.numeric(st_area(.) / 10^6)) %>% 
  mutate(BoroCT2020 = as.numeric(BoroCT2020)) %>% 
  inner_join(., ny_pop, by = "BoroCT2020")

# Convert empty raster to polygons
grid_p <- rasterToPolygons(x = r, dissolve = FALSE) %>% st_as_sf()

# Intersect tracts with polygon grid and calculate area of segments
# then calculate population within each 'cutup' census tract piece
tracts_cut <- st_intersection(x = nytract_pop, y = grid_p) %>% 
  mutate(area_seg = as.numeric(st_area(.) / 10^6)) %>% 
  mutate(pop_seg = area_seg / area * Pop_20)


# Calculate sum of population of tract segments within each cell
# The 'layer' column indicates which cell index the tract segment belongs to
r_pop_vals <- tracts_cut %>% group_by(layer) %>% 
  summarise(., pop = sum(pop_seg, na.rm = TRUE))

# Find cell index for NA values
not_in_df <- data.frame(subset(1:ncell(r), !(1:ncell(r) %in% r_pop_vals$layer)), NA)
names(not_in_df) <- c("layer", "pop")

# Combine values for cells with and without population 
r_pop_vals_full <- rbind(not_in_df, r_pop_vals %>% 
                           as.data.frame() %>% 
                           select(., c("layer", "pop"))) %>% 
  mutate(., layer = as.numeric(layer)) %>% arrange(., layer)

# Create gridded population raster by setting the population column to the empty raster
r_pop <- setValues(r, values = r_pop_vals_full$pop)

# Convert population to integer
r_pop[] <- as.integer(r_pop[])
```

### Tract Population map -- This is the true population

```{r}

ggplot() +
  geom_sf(data = nytract_pop, aes(fill = Pop_20), col = NA) +
  ggtitle("Population by Census Tract") +
  scale_fill_gradient(low = 'lightsteelblue2', high = 'darkblue', 
                      guide = guide_colorbar(ticks = FALSE), 
                      limits = c(0, cellStats(r_pop, max)),
                      oob = scales::squish) +
  xlab('') + ylab('') + 
  labs(caption = paste("True Total Population = ",
                       as.character(sum(nytract_pop$Pop_20)))) +
  theme_bw() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.text.y = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks = element_blank(),
        legend.title = element_blank(),
        legend.position = c(0.1, 0.85)) 
```

```{r}
# Convert raster to dataframe for plotting
r_pop_df <- as.data.frame(rasterToPoints(r_pop))
colnames(r_pop_df) <- c('x', 'y', 'value')
```


### Interpolated Population map -- This is the output

```{r}
ggplot() + 
  geom_raster(aes(x = x, y = y, fill = value), data = r_pop_df) +
  ggtitle("Population Grid from areal interpolation") +
  scale_fill_gradient(low = 'lightsteelblue2', high = 'darkblue', 
                      guide = guide_colorbar(ticks = FALSE),
                      limits = c(0, cellStats(r_pop, max))) +
  labs(caption = paste("Interpolated Population = ", 
                       as.character(cellStats(x = r_pop, stat = "sum")))) +
  xlab('') + ylab('') +
  coord_sf() +
  theme_bw() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.text.y = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks = element_blank(),
        legend.title = element_blank(),
        legend.position = c(0.1, 0.85))
```

# Create gridded building volume from NYC buildings

The maps below compare the true 2020 census tract population to the interpolated population grid.


```{r, eval = FALSE}
## Create building volume grid
# Convert building height to meters, calculate area, then calculate volume

buildings_vol <- buildings %>% 
  mutate(heightroof_1 = as.numeric(heightroof) / 3.281) %>% 
  mutate(area = as.numeric(units::set_units(st_area(.), "m^2"))) %>% 
  mutate(volume = area * heightroof_1)

# Intersect buildings with polygon grid and calculate area of segments
# then find proportional volume
build_cut <- st_intersection(x = st_transform(buildings_vol, st_crs(grid_p)), y = grid_p) %>% 
  mutate(area_seg = as.numeric(units::set_units(st_area(.), m^2))) %>% 
  mutate(volume_seg = area_seg / area * volume)


# Convert to dataframe selecting cell value (layer) and volume of segment
build_cut_df <- build_cut %>% as.data.frame(.) %>% select(., c('layer', 'volume_seg'))

# Find total building volume in each cell
r_bvol_vals <- build_cut_df %>% group_by(layer) %>% 
  summarise(., vol = sum(volume_seg, na.rm = TRUE))

# Find cell index for NA values
not_in_df <- data.frame(subset(1:ncell(r), 
                               !(1:ncell(r) %in% r_bvol_vals$layer)), NA)
names(not_in_df) <- c("layer", "vol")

# Combine values for cells with and without buildings 
r_vol_vals_full <- rbind(not_in_df, r_bvol_vals) %>% 
  mutate(., layer = as.numeric(layer)) %>% arrange(., layer)

# Create gridded building volume raster
r_bvol <- setValues(r, values = r_vol_vals_full$vol)
r_bvol[r_bvol == 0] <- NA


# Convert raster to dataframe for plotting, convert from cubic meters to cubic hectometers
r_bvol_df <- as.data.frame(rasterToPoints(r_bvol / 1000000))
colnames(r_bvol_df) <- c('x', 'y', 'value')

# Get 7 class breaks for visualization
breaks_qt <- classIntervals(
  c(min(r_bvol_df$value) - min(r_bvol_df$value), r_bvol_df$value), 
                            n = 7, style = "fisher")

# Add class breaks as column in the building volume dataframe
r_bvol_df <- mutate(r_bvol_df, value_qt = cut(value, breaks_qt$brks)) 

```

### Interpolated building volume map


```{r}
ggplot() + 
  geom_raster(aes(x = x, y = y, fill = value_qt), data = r_bvol_df) +
  ggtitle("Building Volume Grid from areal interpolation") +
  scale_fill_brewer(palette = "OrRd")  +
  xlab('') + ylab('') + labs(fill = expression(hm^3)) +
  coord_sf() +
  theme_bw() +
  labs(caption = "0.75 hm^3 would be a pixel 100% covered with 1 story houses") +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.text.y = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks = element_blank(),
        legend.position = c(0.15, 0.75)) 
```


# Sample pixels with and without public housing

```{r}
# Upload Public Housing Fractional coverage raster
ph_r <- ph_fraction

# Upload gridded population
pop_r <- r_pop

# Upload gridded building volume, convert to cubic hectometers
bvol_r <- r_bvol / 1000000

# Find PH pixels with at least 10% coverage of tracts with public housing
ph_full_r <- ph_r > 0.1
ph_full_r[ph_full_r == 0] <- NA

# Mask gridded population with PH pixels
pop_ph <- pop_r * ph_full_r

# Quartile class breaks for population for PH pixels
pop_breaks_qt <- classIntervals(c(cellStats(pop_ph, min) - 1, getValues(pop_ph)), 
                            n = 4, style = "quantile")

# Mask gridded building volume
bvol_ph <- bvol_r * ph_full_r

# Quartile breaks for building volume with PH pixels
bv_breaks_qt <- classIntervals(
  c(cellStats(bvol_ph, min) - cellStats(bvol_ph, min), getValues(bvol_ph)), 
                            n = 4, style = "quantile")

# Convert PH pixels greater then 10% coverage to points
ph_p <- rasterToPoints(ph_full_r) %>% as.data.frame() %>% 
  st_as_sf(., coords = c("x", "y"))

# Create column that specifies that pixels contain public housing
# Extract radiance, population, and building volume
# Create columns with population and building volume class breaks
extract_ph_p <- ph_p %>% mutate(., sample = "PH") %>%
  mutate(., radiance = raster::extract(mean_s, .)) %>% 
  mutate(., population = raster::extract(pop_r, .)) %>% 
  mutate(., building_volume = raster::extract(bvol_r, .)) %>% 
  mutate(., pop_class = cut(population, pop_breaks_qt$brks, dig.lab = 4)) %>% 
  mutate(., bvol_class = cut(building_volume, bv_breaks_qt$brks, dig.lab = 2))

# Create a frequency cross tabulation of pixels within population and building 
# volume quartiles.
t <- table(pop = extract_ph_p$pop_class, bvol = extract_ph_p$bvol_class)

# Reformat frequency cross tabulation to a dataframe in order to for query
# and stratified sampling of No PH pixels
t2 <- as.data.frame(t) %>% 
  separate(., col = pop, into = c("pop_l", "pop_u"), sep = ",") %>% 
  separate(., col = bvol, into = c("bvol_l", "bvol_u"), sep = ",") %>% 
  mutate(., pop_l = as.numeric(gsub("\\(", "", pop_l))) %>% 
  mutate(., pop_u = as.numeric(gsub("\\]", "", pop_u))) %>%
  mutate(., bvol_l = as.numeric(gsub("\\(", "", bvol_l))) %>% 
  mutate(., bvol_u = as.numeric(gsub("\\]", "", bvol_u))) %>% 
  filter(., Freq > 0)

# Find pixels with at 0% coverage with public housing
no_ph_r <- ph_r == 0

plot(no_ph_r)

# This lapply masks the NYC extent based on the population class and building volume
# class criteria.  The number of pixels randomly sampled from the No PH raster is the 
# same number in the frequency cross tabulation.  This is done to ensure that the sampled
# No PH pixels represent the same population and building volume conditions as the PH pixels.
set.seed(19)
no_ph <- lapply(1:nrow(t2), function(i) { 
  x <- t2[i, ]
  pop_mask <- pop_r > x$pop_l & pop_r <= x$pop_u
  bvol_mask <- bvol_r > x$bvol_l & bvol_r <= x$bvol_u
  no_ph_r_masked <- no_ph_r * pop_mask * bvol_mask
  no_ph_r_masked[no_ph_r_masked == 0] <- NA
  no_ph_smp <- sampleRandom(x = no_ph_r_masked, size = x$Freq, cells = TRUE)
  return(no_ph_smp[, 1])}) %>% unlist()
# Bind cell index with a column 'layer' set to 1, indicating sampled
no_ph_df <- cbind(cell = no_ph, layer = rep(1, length(no_ph)))

# Find cell index for non sampled pixels and set 'layer' to NA
not_in_df <- data.frame(subset(1:ncell(r), !(1:ncell(r) %in% no_ph)), NA)
names(not_in_df) <- c("cell", "layer")

# Combine values for non-sample and samples
r_smp_df <- rbind(not_in_df, no_ph_df) %>% arrange(., cell)

# Create a raster where No PH sampled pixels are 1, and non sampled pixels are NA
r_smp <- setValues(r, values = r_smp_df$layer)

# Convert No PH sample raster to points
smp_p <- rasterToPoints(r_smp) %>% as.data.frame() %>% 
  st_as_sf(., coords = c("x", "y"), crs = st_crs(mean_s))

# Create column that specifies that pixels do not contain public housing
# Extract radiance, population, and building volume
# Create columns with population and building volume class breaks
extract_noph_p <- smp_p %>% mutate(., sample = "No PH") %>% 
  mutate(., radiance = raster::extract(mean_s, .)) %>% 
  mutate(., population = raster::extract(pop_r, .)) %>% 
  mutate(., building_volume = raster::extract(bvol_r, .)) %>% 
  mutate(., pop_class = cut(population, pop_breaks_qt$brks, dig.lab = 4)) %>% 
  mutate(., bvol_class = cut(building_volume, bv_breaks_qt$brks, dig.lab = 2))

# Combine ph and no ph samples
combined <- rbind(as.data.frame(extract_noph_p), 
                  as.data.frame(extract_ph_p))
```

### Display map of PH and No PH samples 


```{r}
ggplot() + 
  geom_sf(data = nytract, col = "lightgrey", fill = NA) +
  geom_sf(data = combined %>% st_as_sf(), aes(fill = sample, col = sample)) +
  ggtitle("Locations of Samples") +
  scale_color_manual(values = c("red", "blue")) +
  xlab('') + ylab('') +
  theme_bw() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.text.y = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks = element_blank(),
        legend.position = c(0.1, 0.9),
        legend.title= element_blank()) 
```

# Public Housing Lights Analysis - Box Plots


### Create boxplot comparing mean radiance for public housing vs none within population classes

```{r, eval = FALSE}
ggplot(combined, aes(x = pop_class, y = radiance, color = sample, fill = sample)) +
  scale_color_manual(values = c('red', 'blue')) +
  scale_fill_manual(values = alpha(c('red', 'blue'), 0.3)) +
  xlab("Population Class") + ylab("10 year mean radiance") +
  stat_summary(geom = "point", fun = mean, pch = 4, 
               position = position_dodge(.75)) +
  geom_boxplot() +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.title = element_blank())
```

# Create boxplot comparing mean radiance for public housing vs none within building volume classes

```{r, eval = FALSE}
ggplot(combined, aes(x = bvol_class, y = radiance, color = sample, fill = sample)) +
  scale_color_manual(values = c('red', 'blue')) +
  scale_fill_manual(values = alpha(c('red', 'blue'), 0.3)) +
  xlab("Building Volume Class") + ylab("10 year mean radiance") +
  stat_summary(geom = "point", fun = mean, pch = 4, 
               position = position_dodge(.75)) +
  geom_boxplot() +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.title = element_blank()) 

```
